/**
 * RLM (Recursive Language Model) Router
 *
 * Enables deep, multi-step reasoning over codebases using the knowledge graph
 * and vector store. Uses a recursive decompose-execute-aggregate pattern:
 *
 * 1. Decompose: LLM breaks query into sub-tasks (graph_query, vector_search, llm_explain, recurse)
 * 2. Execute: Run each task against services, storing results in context buffers
 * 3. Aggregate: When sufficient context gathered, synthesize final answer (or recurse)
 */

import Anthropic from '@anthropic-ai/sdk';
import { VectorManager } from '../vector/index.js';
import { GraphManager } from '../graph/index.js';
import { GitManager } from '../git/index.js';
import { SymbolNode } from '@cv-git/shared';
import { loadCodebaseSummary, CodebaseSummary } from './codebase-summary.js';
import { GraphService, createGraphService } from './graph-service.js';
import { SemanticGraphService, createSemanticGraphService } from './semantic-graph.js';

// ========== Type Definitions ==========

/**
 * Task types that the RLM Router can execute
 */
export type RLMTaskType =
  | 'graph_query'      // Basic graph queries (callers, callees, symbols)
  | 'vector_search'    // Semantic code search
  | 'llm_explain'      // Request LLM explanation
  | 'recurse'          // Sub-question needing own reasoning chain
  | 'find_path'        // Find call path between two symbols
  | 'get_neighborhood' // Explore code neighborhood around a symbol
  | 'impact_analysis'  // Analyze change impact on a symbol
  | 'semantic_search'  // Combined semantic + graph search
  | 'find_bridge';     // Find code bridging two concepts

/**
 * Context maintained throughout the reasoning process
 */
export interface RLMContext {
  /** The original user query */
  originalQuery: string;
  /** Current recursion depth */
  depth: number;
  /** Maximum allowed recursion depth */
  maxDepth: number;
  /** Results from sub-queries, keyed by task ID */
  buffers: Map<string, any>;
  /** Trace of all reasoning steps taken */
  trace: RLMStep[];
}

/**
 * A single step in the reasoning trace
 */
export interface RLMStep {
  /** Type of task executed */
  taskType: RLMTaskType;
  /** The query or task description */
  query: string;
  /** Result of the task execution */
  result: any;
  /** Depth at which this step occurred */
  depth: number;
  /** Timestamp when the step was executed */
  timestamp: number;
  /** Time taken to execute the step in ms */
  duration?: number;
}

/**
 * A plan generated by the decomposition step
 */
export interface RLMPlan {
  /** Tasks to execute */
  tasks: RLMTask[];
  /** Whether current context is sufficient to answer */
  canAnswer: boolean;
  /** Refined sub-question if recursing */
  refinedQuery?: string;
  /** LLM's reasoning about the plan */
  reasoning: string;
}

/**
 * A single task in an execution plan
 */
export interface RLMTask {
  /** Unique identifier for this task */
  id: string;
  /** Type of task to execute */
  type: RLMTaskType;
  /** Query or description for the task */
  query: string;
  /** Additional parameters for task execution */
  params?: Record<string, any>;
}

/**
 * Final result of the reasoning process
 */
export interface RLMResult {
  /** The synthesized answer */
  answer: string;
  /** Complete trace of reasoning steps */
  trace: RLMStep[];
  /** Final recursion depth reached */
  depth: number;
  /** Sources used to derive the answer */
  sources: string[];
}

/**
 * Options for creating an RLM Router
 */
export interface RLMRouterOptions {
  /** Maximum recursion depth (default: 5) */
  maxDepth?: number;
  /** Maximum tokens for LLM calls */
  maxTokens?: number;
  /** Temperature for LLM calls */
  temperature?: number;
  /** Anthropic API key */
  apiKey: string;
  /** Model to use (default: claude-sonnet-4-5-20250514) */
  model?: string;
  /** Repository root path (for loading codebase summary) */
  repoRoot?: string;
}

// ========== RLM Router Implementation ==========

export class RLMRouter {
  private client: Anthropic;
  private model: string;
  private maxDepth: number;
  private maxTokens: number;
  private temperature: number;
  private repoRoot?: string;
  private codebaseSummary?: CodebaseSummary;
  private graphService?: GraphService;
  private semanticGraphService?: SemanticGraphService;

  constructor(
    private options: RLMRouterOptions,
    private vector?: VectorManager,
    private graph?: GraphManager,
    private git?: GitManager
  ) {
    this.client = new Anthropic({ apiKey: options.apiKey });
    this.model = options.model || 'claude-sonnet-4-5-20250514';
    this.maxDepth = options.maxDepth || 5;
    this.maxTokens = options.maxTokens || 4096;
    this.temperature = options.temperature || 0.3; // Lower temp for more focused reasoning
    this.repoRoot = options.repoRoot;

    // Initialize advanced services if graph/vector managers are available
    if (graph) {
      this.graphService = createGraphService(graph);
    }
    if (graph && vector) {
      this.semanticGraphService = createSemanticGraphService(graph, vector);
    }
  }

  /**
   * Load codebase summary for context
   */
  async loadSummary(): Promise<CodebaseSummary | null> {
    if (!this.repoRoot) return null;

    if (!this.codebaseSummary) {
      this.codebaseSummary = await loadCodebaseSummary(this.repoRoot) || undefined;
    }

    return this.codebaseSummary || null;
  }

  /**
   * Get a concise summary context string for prompts
   */
  private getSummaryContext(): string {
    if (!this.codebaseSummary) return '';

    const summary = this.codebaseSummary;
    const parts: string[] = [];

    parts.push('## Codebase Context');
    parts.push(`Files: ${summary.stats.totalFiles}, Symbols: ${summary.stats.totalSymbols}`);

    const langs = Object.entries(summary.stats.languages)
      .sort((a: any, b: any) => b[1] - a[1])
      .slice(0, 3)
      .map(([lang, count]) => `${lang}(${count})`)
      .join(', ');
    if (langs) {
      parts.push(`Languages: ${langs}`);
    }

    if (summary.architecture.patterns.length > 0) {
      parts.push(`Patterns: ${summary.architecture.patterns.join(', ')}`);
    }

    if (summary.architecture.coreModules.length > 0) {
      const modules = summary.architecture.coreModules.slice(0, 5).map(m => m.name).join(', ');
      parts.push(`Core Modules: ${modules}`);
    }

    if (summary.architecture.entryPoints.length > 0) {
      parts.push(`Entry Points: ${summary.architecture.entryPoints.slice(0, 3).join(', ')}`);
    }

    return parts.join('\n');
  }

  /**
   * Main entry point for deep reasoning
   *
   * @param query - The question or task to reason about
   * @param ctx - Optional partial context to resume from
   * @returns The reasoning result with answer and trace
   */
  async reason(query: string, ctx?: Partial<RLMContext>): Promise<RLMResult> {
    // Load codebase summary for context (only at the root level)
    if (!ctx?.depth || ctx.depth === 0) {
      await this.loadSummary();
    }

    // Initialize context
    const context: RLMContext = {
      originalQuery: ctx?.originalQuery || query,
      depth: ctx?.depth || 0,
      maxDepth: ctx?.maxDepth || this.maxDepth,
      buffers: ctx?.buffers || new Map(),
      trace: ctx?.trace || []
    };

    // Check depth limit
    if (context.depth >= context.maxDepth) {
      return this.aggregate(context, true); // Force aggregation at max depth
    }

    // Decompose the query into sub-tasks
    const plan = await this.decompose(query, context);

    // If we can answer directly, aggregate and return
    if (plan.canAnswer) {
      return this.aggregate(context, false);
    }

    // Execute each task in the plan
    for (const task of plan.tasks) {
      const startTime = Date.now();
      const result = await this.executeTask(task, context);
      const duration = Date.now() - startTime;

      // Store result in buffer
      context.buffers.set(task.id, result);

      // Record step in trace
      context.trace.push({
        taskType: task.type,
        query: task.query,
        result,
        depth: context.depth,
        timestamp: Date.now(),
        duration
      });

      // If this was a recursive task, merge its trace
      if (task.type === 'recurse' && result?.trace) {
        // Recursive trace is already included in the result
      }
    }

    // After executing all tasks, try to answer
    // Use the refined query if one was provided, otherwise use original
    const nextQuery = plan.refinedQuery || query;

    // Increment depth and recurse
    context.depth++;

    // Check if we should recurse or aggregate
    const finalPlan = await this.decompose(nextQuery, context);

    if (finalPlan.canAnswer || context.depth >= context.maxDepth) {
      return this.aggregate(context, context.depth >= context.maxDepth);
    }

    // Recurse with updated context
    return this.reason(nextQuery, context);
  }

  /**
   * Decompose a query into sub-tasks using the LLM
   */
  async decompose(query: string, ctx: RLMContext): Promise<RLMPlan> {
    // Build buffer summary
    const bufferSummary = this.summarizeBuffers(ctx.buffers);

    // Include codebase summary context
    const summaryContext = this.getSummaryContext();

    const prompt = `You are a codebase reasoning engine. Given this query and current context,
determine what additional information is needed to answer completely.

${summaryContext ? summaryContext + '\n\n' : ''}Query: ${query}
Original Query: ${ctx.originalQuery}
Current Context:
${bufferSummary || '(No context gathered yet)'}

Depth: ${ctx.depth}/${ctx.maxDepth}

You have access to these task types:
- graph_query: Query code relationships (callers, callees, imports, exports, dependencies)
- vector_search: Semantic search for code snippets related to a concept
- llm_explain: Request explanation of gathered context
- recurse: Break into a sub-question that needs its own reasoning chain
- find_path: Find the call path between two symbols (params: { source, target })
- get_neighborhood: Explore code neighborhood around a symbol (params: { symbol, depth? })
- impact_analysis: Analyze change impact on a symbol (params: { symbol })
- semantic_search: Combined semantic + graph search for richer context (params: { query })
- find_bridge: Find code that bridges two concepts (params: { concept1, concept2 })

Return a JSON response with:
{
  "tasks": [
    { "id": "unique_id", "type": "task_type", "query": "specific query", "params": {} }
  ],
  "canAnswer": boolean,  // true if current context is sufficient to answer
  "refinedQuery": "refined sub-question if recursing",
  "reasoning": "brief explanation of your plan"
}

Guidelines:
- If you have enough context to fully answer the query, set canAnswer to true and return empty tasks
- For graph_query, use natural language describing the relationship (e.g., "what functions call handleAuth")
- For vector_search, describe what code you're looking for semantically
- Only use recurse for genuinely complex sub-questions that need their own reasoning chain
- Aim for 1-3 tasks per decomposition to avoid over-fetching
- Consider what you've already gathered in the context

Return ONLY valid JSON, no markdown formatting.`;

    try {
      const response = await this.client.messages.create({
        model: this.model,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        messages: [{ role: 'user', content: prompt }]
      });

      const text = response.content[0].type === 'text' ? response.content[0].text : '';

      // Parse JSON from response
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          tasks: parsed.tasks || [],
          canAnswer: parsed.canAnswer || false,
          refinedQuery: parsed.refinedQuery,
          reasoning: parsed.reasoning || ''
        };
      }

      // Fallback if parsing fails
      return {
        tasks: [],
        canAnswer: true,
        reasoning: 'Could not parse decomposition response, attempting direct answer'
      };

    } catch (error: any) {
      console.error('Decomposition failed:', error.message);
      return {
        tasks: [],
        canAnswer: true,
        reasoning: `Decomposition error: ${error.message}`
      };
    }
  }

  /**
   * Execute a single task and return its result
   */
  async executeTask(task: RLMTask, ctx: RLMContext): Promise<any> {
    switch (task.type) {
      case 'graph_query':
        return this.executeGraphQuery(task, ctx);

      case 'vector_search':
        return this.executeVectorSearch(task, ctx);

      case 'llm_explain':
        return this.executeLLMExplain(task, ctx);

      case 'recurse':
        return this.executeRecurse(task, ctx);

      case 'find_path':
        return this.executeFindPath(task, ctx);

      case 'get_neighborhood':
        return this.executeGetNeighborhood(task, ctx);

      case 'impact_analysis':
        return this.executeImpactAnalysis(task, ctx);

      case 'semantic_search':
        return this.executeSemanticSearch(task, ctx);

      case 'find_bridge':
        return this.executeFindBridge(task, ctx);

      default:
        throw new Error(`Unknown task type: ${task.type}`);
    }
  }

  /**
   * Execute a graph query task
   */
  private async executeGraphQuery(task: RLMTask, _ctx: RLMContext): Promise<any> {
    if (!this.graph) {
      return { error: 'Graph manager not available' };
    }

    const query = task.query.toLowerCase();
    const params = task.params || {};

    try {
      // Interpret natural language query and map to graph operations
      if (query.includes('call') && query.includes('what')) {
        // "what calls X" -> getCallers
        const targetMatch = query.match(/call[s]?\s+(\w+)/i) || query.match(/(\w+)\s*\?/);
        if (targetMatch) {
          const target = params.target || targetMatch[1];
          const callers = await this.graph.getCallers(target);
          return {
            type: 'callers',
            target,
            results: callers.map((s: SymbolNode) => ({
              name: s.name,
              file: s.file,
              line: s.startLine,
              kind: s.kind
            }))
          };
        }
      }

      if (query.includes('calls') || query.includes('dependencies')) {
        // "what does X call" -> getCallees
        const targetMatch = query.match(/does\s+(\w+)\s+call/i) || query.match(/(\w+)\s+call/i);
        if (targetMatch) {
          const target = params.target || targetMatch[1];
          const callees = await this.graph.getCallees(target);
          return {
            type: 'callees',
            target,
            results: callees.map((s: SymbolNode) => ({
              name: s.name,
              file: s.file,
              line: s.startLine,
              kind: s.kind
            }))
          };
        }
      }

      if (query.includes('symbol') || query.includes('function') || query.includes('class')) {
        // Symbol lookup
        const targetMatch = query.match(/(?:symbol|function|class)\s+(\w+)/i);
        if (targetMatch) {
          const target = params.target || targetMatch[1];
          const symbol = await this.graph.getSymbolNode(target);
          return {
            type: 'symbol',
            target,
            result: symbol ? {
              name: symbol.name,
              kind: symbol.kind,
              file: symbol.file,
              startLine: symbol.startLine,
              endLine: symbol.endLine,
              docstring: symbol.docstring,
              signature: symbol.signature
            } : null
          };
        }
      }

      if (query.includes('file') && query.includes('symbols')) {
        // File symbols
        const targetMatch = query.match(/in\s+([^\s]+)/i);
        if (targetMatch) {
          const filePath = params.file || targetMatch[1];
          const symbols = await this.graph.getFileSymbols(filePath);
          return {
            type: 'file_symbols',
            file: filePath,
            results: symbols.map((s: SymbolNode) => ({
              name: s.name,
              kind: s.kind,
              line: s.startLine
            }))
          };
        }
      }

      if (query.includes('stats') || query.includes('statistics')) {
        const stats = await this.graph.getStats();
        return { type: 'stats', results: stats };
      }

      // Fallback: try to find a symbol by name from the query
      const words = query.split(/\s+/).filter(w => w.length > 2 && /^[a-zA-Z]/.test(w));
      for (const word of words) {
        const symbol = await this.graph.getSymbolNode(word);
        if (symbol) {
          return {
            type: 'symbol',
            target: word,
            result: {
              name: symbol.name,
              kind: symbol.kind,
              file: symbol.file,
              startLine: symbol.startLine,
              endLine: symbol.endLine,
              docstring: symbol.docstring
            }
          };
        }
      }

      return { type: 'unknown', query: task.query, message: 'Could not interpret graph query' };

    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute a vector search task
   */
  private async executeVectorSearch(task: RLMTask, _ctx: RLMContext): Promise<any> {
    if (!this.vector) {
      return { error: 'Vector manager not available' };
    }

    try {
      const limit = task.params?.limit || 5;
      const minScore = task.params?.minScore || 0.3;

      const results = await this.vector.searchCode(task.query, limit, { minScore });

      return {
        type: 'vector_search',
        query: task.query,
        results: results.map(r => ({
          file: r.payload.file,
          startLine: r.payload.startLine,
          endLine: r.payload.endLine,
          symbolName: r.payload.symbolName,
          symbolKind: r.payload.symbolKind,
          text: r.payload.text?.substring(0, 500) + (r.payload.text?.length > 500 ? '...' : ''),
          score: r.score,
          language: r.payload.language
        }))
      };

    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute an LLM explain task
   */
  private async executeLLMExplain(task: RLMTask, ctx: RLMContext): Promise<any> {
    // Build context from buffers
    const bufferSummary = this.summarizeBuffers(ctx.buffers);

    const prompt = `Based on the following gathered context about a codebase, provide a focused explanation:

Question: ${task.query}

Gathered Context:
${bufferSummary}

Provide a clear, technical explanation. Focus on:
1. What the code does
2. How it works
3. Key relationships and dependencies
4. Important design decisions

Keep the explanation concise and focused on the question.`;

    try {
      const response = await this.client.messages.create({
        model: this.model,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        messages: [{ role: 'user', content: prompt }]
      });

      const text = response.content[0].type === 'text' ? response.content[0].text : '';
      return { type: 'explanation', query: task.query, text };

    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute a recursive reasoning task
   */
  private async executeRecurse(task: RLMTask, ctx: RLMContext): Promise<any> {
    // Create a new context for the recursive call
    const subContext: Partial<RLMContext> = {
      originalQuery: ctx.originalQuery,
      depth: ctx.depth + 1,
      maxDepth: ctx.maxDepth,
      buffers: new Map(), // Fresh buffers for sub-query
      trace: [] // Fresh trace, will be merged
    };

    try {
      const result = await this.reason(task.query, subContext);
      return {
        type: 'recurse',
        query: task.query,
        answer: result.answer,
        trace: result.trace,
        depth: result.depth,
        sources: result.sources
      };
    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute a find_path task - find call path between two symbols
   */
  private async executeFindPath(task: RLMTask, _ctx: RLMContext): Promise<any> {
    if (!this.graphService) {
      return { error: 'Graph service not available' };
    }

    const params = task.params || {};
    const source = params.source || this.extractSymbolFromQuery(task.query, 'from');
    const target = params.target || this.extractSymbolFromQuery(task.query, 'to');

    if (!source || !target) {
      return { error: 'Could not determine source and target symbols from query' };
    }

    try {
      const result = await this.graphService.findPath(source, target, { maxDepth: params.maxDepth });
      return {
        type: 'find_path',
        source,
        target,
        ...result
      };
    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute a get_neighborhood task - explore code neighborhood
   */
  private async executeGetNeighborhood(task: RLMTask, _ctx: RLMContext): Promise<any> {
    if (!this.graphService) {
      return { error: 'Graph service not available' };
    }

    const params = task.params || {};
    const symbol = params.symbol || this.extractSymbolFromQuery(task.query, 'symbol');

    if (!symbol) {
      return { error: 'Could not determine symbol from query' };
    }

    try {
      const result = await this.graphService.getNeighborhood(symbol, {
        depth: params.depth || 2,
        maxNodes: params.maxNodes || 30
      });
      return {
        type: 'get_neighborhood',
        symbol,
        ...result
      };
    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute an impact_analysis task - analyze change impact
   */
  private async executeImpactAnalysis(task: RLMTask, _ctx: RLMContext): Promise<any> {
    if (!this.graphService) {
      return { error: 'Graph service not available' };
    }

    const params = task.params || {};
    const symbol = params.symbol || this.extractSymbolFromQuery(task.query, 'symbol');

    if (!symbol) {
      return { error: 'Could not determine symbol from query' };
    }

    try {
      const result = await this.graphService.getImpactAnalysis(symbol, {
        maxDepth: params.maxDepth || 3
      });
      return {
        type: 'impact_analysis',
        ...result
      };
    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute a semantic_search task - combined semantic + graph search
   */
  private async executeSemanticSearch(task: RLMTask, _ctx: RLMContext): Promise<any> {
    if (!this.semanticGraphService) {
      return { error: 'Semantic graph service not available' };
    }

    const params = task.params || {};
    const query = params.query || task.query;

    try {
      const results = await this.semanticGraphService.semanticSearch(query, {
        semanticLimit: params.limit || 5,
        minScore: params.minScore || 0.4,
        includeCallers: true,
        includeCallees: true
      });
      return {
        type: 'semantic_search',
        query,
        results: results.map(r => ({
          name: r.symbol.name,
          file: r.symbol.file,
          kind: r.symbol.kind,
          startLine: r.symbol.startLine,
          semanticScore: r.semanticScore,
          matchedText: r.matchedText?.substring(0, 200),
          callers: r.graphContext.callers.slice(0, 3),
          callees: r.graphContext.callees.slice(0, 3)
        }))
      };
    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Execute a find_bridge task - find code bridging two concepts
   */
  private async executeFindBridge(task: RLMTask, _ctx: RLMContext): Promise<any> {
    if (!this.semanticGraphService) {
      return { error: 'Semantic graph service not available' };
    }

    const params = task.params || {};
    const concept1 = params.concept1 || this.extractConceptFromQuery(task.query, 1);
    const concept2 = params.concept2 || this.extractConceptFromQuery(task.query, 2);

    if (!concept1 || !concept2) {
      return { error: 'Could not determine both concepts from query' };
    }

    try {
      const result = await this.semanticGraphService.findSemanticBridge(concept1, concept2, {
        limit: params.limit || 10
      });
      return {
        type: 'find_bridge',
        concept1,
        concept2,
        bridgeSymbols: result.bridgeSymbols,
        sharedCallers: result.sharedCallers,
        sharedCallees: result.sharedCallees
      };
    } catch (error: any) {
      return { error: error.message };
    }
  }

  /**
   * Helper to extract symbol name from natural language query
   */
  private extractSymbolFromQuery(query: string, context: 'from' | 'to' | 'symbol'): string | null {
    const patterns: Record<string, RegExp[]> = {
      'from': [
        /from\s+(\w+)/i,
        /path\s+(\w+)\s+to/i,
        /between\s+(\w+)\s+and/i
      ],
      'to': [
        /to\s+(\w+)/i,
        /path\s+\w+\s+to\s+(\w+)/i,
        /between\s+\w+\s+and\s+(\w+)/i,
        /reach\w*\s+(\w+)/i
      ],
      'symbol': [
        /(?:for|of|around|neighborhood)\s+(\w+)/i,
        /(\w+)\s+(?:neighborhood|impact|analysis)/i,
        /^(\w+)$/
      ]
    };

    for (const pattern of patterns[context]) {
      const match = query.match(pattern);
      if (match) return match[1];
    }

    // Fallback: find any word that looks like a symbol name (PascalCase or camelCase)
    const words = query.split(/\s+/);
    for (const word of words) {
      if (/^[A-Z][a-zA-Z]+$/.test(word) || /^[a-z]+[A-Z][a-zA-Z]*$/.test(word)) {
        return word;
      }
    }

    return null;
  }

  /**
   * Helper to extract concepts from bridge query
   */
  private extractConceptFromQuery(query: string, position: 1 | 2): string | null {
    // Try to extract concepts separated by "and", "to", "with", etc.
    const patterns = [
      /between\s+"([^"]+)"\s+and\s+"([^"]+)"/i,
      /between\s+(\w+)\s+and\s+(\w+)/i,
      /bridge\s+(\w+)\s+(?:and|to|with)\s+(\w+)/i,
      /connect(?:ing|s)?\s+(\w+)\s+(?:and|to|with)\s+(\w+)/i
    ];

    for (const pattern of patterns) {
      const match = query.match(pattern);
      if (match) {
        return position === 1 ? match[1] : match[2];
      }
    }

    // Fallback: split on common delimiters
    const parts = query.split(/\s+(?:and|to|with)\s+/i);
    if (parts.length >= 2) {
      return parts[position - 1]?.trim()?.split(/\s+/).pop() || null;
    }

    return null;
  }

  /**
   * Aggregate context and synthesize final answer
   */
  async aggregate(ctx: RLMContext, forced: boolean): Promise<RLMResult> {
    const bufferSummary = this.summarizeBuffers(ctx.buffers);
    const traceSummary = this.summarizeTrace(ctx.trace);

    const prompt = `You are synthesizing the final answer to a codebase question based on gathered context.

Original Question: ${ctx.originalQuery}

Gathered Context:
${bufferSummary || '(No specific context gathered)'}

Reasoning Trace:
${traceSummary || '(No reasoning steps taken)'}

${forced ? 'Note: Maximum reasoning depth reached. Provide the best answer with available information.' : ''}

Synthesize a comprehensive answer that:
1. Directly addresses the original question
2. Incorporates all relevant findings from the context
3. Explains relationships and dependencies discovered
4. Notes any limitations or areas that couldn't be fully explored

Provide the answer in clear, technical prose. If code examples would help, include them.`;

    try {
      const response = await this.client.messages.create({
        model: this.model,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        messages: [{ role: 'user', content: prompt }]
      });

      const answer = response.content[0].type === 'text' ? response.content[0].text : '';

      // Extract sources from trace
      const sources = this.extractSources(ctx.trace);

      return {
        answer,
        trace: ctx.trace,
        depth: ctx.depth,
        sources
      };

    } catch (error: any) {
      return {
        answer: `Error synthesizing answer: ${error.message}`,
        trace: ctx.trace,
        depth: ctx.depth,
        sources: []
      };
    }
  }

  /**
   * Summarize buffers for prompt context
   */
  private summarizeBuffers(buffers: Map<string, any>): string {
    if (buffers.size === 0) return '';

    const parts: string[] = [];
    for (const [id, value] of buffers) {
      if (value.error) {
        parts.push(`[${id}] Error: ${value.error}`);
        continue;
      }

      switch (value.type) {
        case 'callers':
          if (value.results?.length > 0) {
            parts.push(`[${id}] Functions that call ${value.target}:`);
            value.results.forEach((r: any) => {
              parts.push(`  - ${r.name} (${r.kind}) in ${r.file}:${r.line}`);
            });
          } else {
            parts.push(`[${id}] No callers found for ${value.target}`);
          }
          break;

        case 'callees':
          if (value.results?.length > 0) {
            parts.push(`[${id}] Functions called by ${value.target}:`);
            value.results.forEach((r: any) => {
              parts.push(`  - ${r.name} (${r.kind}) in ${r.file}:${r.line}`);
            });
          } else {
            parts.push(`[${id}] No callees found for ${value.target}`);
          }
          break;

        case 'symbol':
          if (value.result) {
            const s = value.result;
            parts.push(`[${id}] Symbol: ${s.name} (${s.kind})`);
            parts.push(`  File: ${s.file}:${s.startLine}-${s.endLine}`);
            if (s.signature) parts.push(`  Signature: ${s.signature}`);
            if (s.docstring) parts.push(`  Doc: ${s.docstring.substring(0, 200)}`);
          } else {
            parts.push(`[${id}] Symbol not found: ${value.target}`);
          }
          break;

        case 'vector_search':
          if (value.results?.length > 0) {
            parts.push(`[${id}] Semantic search results for "${value.query}":`);
            value.results.forEach((r: any) => {
              parts.push(`  - ${r.symbolName || 'code'} in ${r.file}:${r.startLine} (score: ${r.score.toFixed(2)})`);
              if (r.text) parts.push(`    ${r.text.substring(0, 150)}...`);
            });
          } else {
            parts.push(`[${id}] No results for search: "${value.query}"`);
          }
          break;

        case 'explanation':
          parts.push(`[${id}] Explanation for "${value.query}":`);
          parts.push(value.text);
          break;

        case 'recurse':
          parts.push(`[${id}] Sub-query: "${value.query}"`);
          parts.push(`  Answer: ${value.answer?.substring(0, 300)}...`);
          parts.push(`  Depth: ${value.depth}, Sources: ${value.sources?.length || 0}`);
          break;

        case 'file_symbols':
          if (value.results?.length > 0) {
            parts.push(`[${id}] Symbols in ${value.file}:`);
            value.results.forEach((r: any) => {
              parts.push(`  - ${r.name} (${r.kind}) at line ${r.line}`);
            });
          }
          break;

        case 'stats':
          parts.push(`[${id}] Codebase statistics:`);
          const stats = value.results;
          parts.push(`  Files: ${stats.fileCount}, Symbols: ${stats.symbolCount}`);
          parts.push(`  Functions: ${stats.functionCount}, Classes: ${stats.classCount}`);
          break;

        case 'find_path':
          if (value.found) {
            parts.push(`[${id}] Path from ${value.source} to ${value.target}:`);
            parts.push(`  Path: ${value.path?.join(' â†’ ')}`);
            parts.push(`  Length: ${value.length}`);
            if (value.explanation) parts.push(`  ${value.explanation}`);
          } else {
            parts.push(`[${id}] No path found from ${value.source} to ${value.target}`);
          }
          break;

        case 'get_neighborhood':
          parts.push(`[${id}] Neighborhood of ${value.symbol}:`);
          if (value.center) {
            parts.push(`  Center: ${value.center.name} (${value.center.type}) in ${value.center.file}`);
          }
          if (value.nodes?.length > 0) {
            parts.push(`  Connected nodes (${value.summary?.totalNodes || value.nodes.length}):`);
            value.nodes.slice(0, 10).forEach((n: any) => {
              parts.push(`    - ${n.name} (${n.type}) via ${n.relationship}, distance: ${n.distance}`);
            });
            if (value.nodes.length > 10) {
              parts.push(`    ... and ${value.nodes.length - 10} more`);
            }
          }
          break;

        case 'impact_analysis':
          parts.push(`[${id}] Impact analysis for ${value.target?.name}:`);
          parts.push(`  Risk level: ${value.riskLevel} (${value.totalImpact} affected)`);
          if (value.riskExplanation) parts.push(`  ${value.riskExplanation}`);
          if (value.directCallers?.length > 0) {
            parts.push(`  Direct callers: ${value.directCallers.slice(0, 5).map((c: any) => c.name).join(', ')}`);
          }
          if (value.indirectCallers?.length > 0) {
            parts.push(`  Indirect callers: ${value.indirectCallers.length}`);
          }
          if (value.affectedFiles?.length > 0) {
            parts.push(`  Affected files: ${value.affectedFiles.slice(0, 5).join(', ')}`);
          }
          break;

        case 'semantic_search':
          if (value.results?.length > 0) {
            parts.push(`[${id}] Semantic+graph search for "${value.query}":`);
            value.results.forEach((r: any) => {
              parts.push(`  - ${r.name} (${r.kind}) in ${r.file}:${r.startLine} (score: ${r.semanticScore?.toFixed(2)})`);
              if (r.callers?.length > 0) parts.push(`    Called by: ${r.callers.join(', ')}`);
              if (r.callees?.length > 0) parts.push(`    Calls: ${r.callees.join(', ')}`);
            });
          } else {
            parts.push(`[${id}] No results for semantic search: "${value.query}"`);
          }
          break;

        case 'find_bridge':
          parts.push(`[${id}] Bridge between "${value.concept1}" and "${value.concept2}":`);
          if (value.bridgeSymbols?.length > 0) {
            parts.push(`  Bridge symbols:`);
            value.bridgeSymbols.slice(0, 5).forEach((b: any) => {
              parts.push(`    - ${b.name} (${b.kind}) relevance: ${b.relevanceToFirst?.toFixed(2)}/${b.relevanceToSecond?.toFixed(2)}`);
            });
          }
          if (value.sharedCallers?.length > 0) {
            parts.push(`  Shared callers: ${value.sharedCallers.slice(0, 5).join(', ')}`);
          }
          if (value.sharedCallees?.length > 0) {
            parts.push(`  Shared callees: ${value.sharedCallees.slice(0, 5).join(', ')}`);
          }
          break;

        default:
          parts.push(`[${id}] ${JSON.stringify(value).substring(0, 200)}`);
      }
    }

    return parts.join('\n');
  }

  /**
   * Summarize trace for aggregation prompt
   */
  private summarizeTrace(trace: RLMStep[]): string {
    if (trace.length === 0) return '';

    return trace.map((step, i) => {
      const duration = step.duration ? ` (${step.duration}ms)` : '';
      return `${i + 1}. [Depth ${step.depth}] ${step.taskType}: ${step.query.substring(0, 100)}${duration}`;
    }).join('\n');
  }

  /**
   * Extract sources from trace
   */
  private extractSources(trace: RLMStep[]): string[] {
    const sources = new Set<string>();

    for (const step of trace) {
      if (step.result?.error) continue;

      switch (step.result?.type) {
        case 'symbol':
          if (step.result.result?.file) {
            sources.add(`${step.result.result.file}:${step.result.result.startLine}`);
          }
          break;

        case 'callers':
        case 'callees':
        case 'file_symbols':
          step.result.results?.forEach((r: any) => {
            if (r.file) sources.add(`${r.file}:${r.line || 1}`);
          });
          break;

        case 'vector_search':
          step.result.results?.forEach((r: any) => {
            if (r.file) sources.add(`${r.file}:${r.startLine}`);
          });
          break;

        case 'recurse':
          step.result.sources?.forEach((s: string) => sources.add(s));
          break;

        case 'find_path':
          step.result.pathDetails?.forEach((d: any) => {
            if (d.file) sources.add(`${d.file}:${d.line || 1}`);
          });
          break;

        case 'get_neighborhood':
          if (step.result.center?.file) {
            sources.add(`${step.result.center.file}:${step.result.center.line || 1}`);
          }
          step.result.nodes?.forEach((n: any) => {
            if (n.file) sources.add(`${n.file}:${n.line || 1}`);
          });
          break;

        case 'impact_analysis':
          if (step.result.target?.file) {
            sources.add(`${step.result.target.file}:1`);
          }
          step.result.directCallers?.forEach((c: any) => {
            if (c.file) sources.add(`${c.file}:1`);
          });
          step.result.affectedFiles?.forEach((f: string) => {
            sources.add(`${f}:1`);
          });
          break;

        case 'semantic_search':
          step.result.results?.forEach((r: any) => {
            if (r.file) sources.add(`${r.file}:${r.startLine || 1}`);
          });
          break;

        case 'find_bridge':
          step.result.bridgeSymbols?.forEach((b: any) => {
            if (b.file) sources.add(`${b.file}:1`);
          });
          break;
      }
    }

    return Array.from(sources);
  }

  /**
   * Format the trace for display
   */
  formatTrace(trace: RLMStep[]): string {
    const lines: string[] = ['Reasoning Trace:', ''];

    for (const step of trace) {
      const indent = '  '.repeat(step.depth);
      const duration = step.duration ? ` (${step.duration}ms)` : '';
      lines.push(`${indent}[${step.taskType}]${duration}`);
      lines.push(`${indent}  Query: ${step.query}`);

      if (step.result?.error) {
        lines.push(`${indent}  Error: ${step.result.error}`);
      } else if (step.result?.type === 'explanation') {
        lines.push(`${indent}  Result: ${step.result.text?.substring(0, 100)}...`);
      } else if (step.result?.results) {
        lines.push(`${indent}  Results: ${step.result.results.length} items`);
      } else if (step.result?.result) {
        lines.push(`${indent}  Found: ${step.result.result.name || 'unknown'}`);
      }

      lines.push('');
    }

    return lines.join('\n');
  }
}

/**
 * Create an RLM Router instance
 */
export function createRLMRouter(
  options: RLMRouterOptions,
  vector?: VectorManager,
  graph?: GraphManager,
  git?: GitManager
): RLMRouter {
  return new RLMRouter(options, vector, graph, git);
}
